 em   ciência da computação    uma    expressão regular     ou o   estrangeirismo        regex       abreviação do   língua inglesa inglês     regular expression    provê uma forma concisa e flexível de identificar   cadeia de caracteres cadeias de caracteres   de interesse  como   caractere  s particulares  palavras ou padrões de caracteres  expressões regulares são escritas numa   linguagem formal   que pode ser   linguagem interpretada interpretada   por um processador de expressão regular  um   programa de computador programa   que serve um   gerador de analisador sintático   ou examina o texto e identifica as partes que   casamento de padrões casam   com a especificação dada o termo deriva do trabalho do   matemático     estados unidos norte-americano     stephen cole kleene    que desenvolveu as expressões regulares como uma notação ao que ele chamava de   álgebra de kleene álgebra de conjuntos regulares    seu trabalho serviu de base para os primeiros   algoritmo de busca algoritmos computacionais de busca    e depois para algumas das mais antigas ferramentas de tratamento de texto da plataforma   unix   o uso atual de expressões regulares inclui procura e substituição de texto em   editor de texto editores de texto   e   linguagem de programação linguagens de programação    validação de formatos de texto  validação de protocolos ou formatos digitais     realce de sintaxe   e filtragem de informação    conceitos básicos   uma expressão regular  ou  um padrão  descreve um conjunto de   cadeia de caracteres cadeias de caracteres    de forma concisa  sem precisar listar todos os elementos do conjunto  por exemplo  um conjunto contendo as cadeias    handel        h ndel    e    haendel    pode ser descrito pelo padrão  code h   ae  ndel  code   a maioria dos formalismos provê pelo menos três operações para construir expressões regulares a primeira delas é a alternância  em que uma   barra vertical     code    code   separa alternativas  por exemplo   code psicadélico psicodélico  code  pode casar    psicadélico    ou    psicodélico     a segunda operação é o agrupamento  em que   parênteses     code    code    code    code   são usados para definir o escopo e a precedência de operadores  entre outros usos  por exemplo   code psicadélico psicodélico  code  e  code psic a o délico  code  são equivalentes e ambas descrevem    psicadélico    e    psicodélico     por fim  a terceira operação é a quantificação  ou repetição   um quantificador após um     token      como um caractere  ou um agrupamento especifica a quantidade de vezes que o elemento precedente pode ocorrer  os quantificadores mais comuns são  code    code    code    code  e  code    code   o   ponto de interrogação   indica que há zero ou uma ocorrência do elemento precedente  por exemplo   code ac ção  code  casa tanto    acção    quanto    ação     já o   asterisco   indica que há zero ou mais ocorrências do elemento precedente  por exemplo   code ab c  code  casa    ac        abc        abbc        abbbc     e assim por diante  por fim  o   símbolos matemáticos sinal de adição   indica que há uma ou mais ocorrências do elemento precedente  por exemplo   code ab c  code  casa    abc        abbc        abbbc     e assim por diante  mas não    ac    essas construções podem ser combinadas arbitrariamente para formar expressões complexas  assim como expressões aritméticas com números e operações de adição  subtração  multiplicação e divisão  de forma geral  há diversas expressões regulares para descrever um mesmo conjunto de cadeias de caracteres  a sintaxe exata da expressão regular e os operadores disponíveis variam entre as implementações    história   a origem das expressões regulares estão na   teoria dos autômatos   e na   linguagem formal teoria das linguagens formais    e ambas fazem parte da   teoria da computação    esses campos estudam modelos de computação  autômatas  e formas de descrição e classificação de linguagens formais  na   década de 1950    o matemático   stephen cole kleene   descreveu tais modelos usando sua notação matemática chamada de  conjuntos regulares   formando a   álgebra de kleene    a linguagem   snobol   foi uma implementação pioneira de   casamento de padrões    mas não era idêntica às expressões regulares    ken thompson   construiu a notação de kleene no   editor de texto     qed  software  qed   como uma forma de casamento de padrões em   arquivo de texto arquivos de texto    posteriormente  ele adicionou essa funcionalidade no editor de texto   unix     ed  software  ed    que resultou no uso de expressões regulares na popular ferramenta de busca   grep    desde então  diversas variações da adaptação original de thompson foram usadas em unix e derivados  incluindo   expr      awk      emacs      vi   e   lex   as expressões regulares de   perl   e   tcl   foram derivadas da biblioteca escrita por   henry spencer    e no perl a funcionalidade foi expandida posteriormente  ref   ref    philip hazel   desenvolveu a   perl compatible regular expressions pcre    perl compatible regular expressions   uma   biblioteca de rotinas biblioteca   usada por diversas ferramentas modernas como   php   e o   servidor apache    parte do desenvolvimento do   perl 6   foi melhorar a integração das expressões regulares de perl  e aumentar seu escopo e funcionalidade para permitir a definição de   gramática de expressão de analisadores sintáticos gramáticas de expressão de analisadores sintáticos    ref name  apocalypse5    ref  o resultado foi uma mini-linguagem  as regras do perl 6  usada para definir a gramática do perl 6 assim como fornecer uma ferramenta para programadores da linguagem  tais regras mantiveram as funcionalidades de expressões regulares do perl 5 x  mas também permitiram uma definição   formalismo de backus-naur bnf   de um   analisador sintático descendente recursivo   o uso de expressões regulares em normas de informação estruturada para a modelagem de documentos e   banco de dados bancos de dados   começou na   década de 1960    e expandiu na   década de 1980   quando normas como a   standard generalized markup language iso sgml   foram consolidadas    teoria de linguagens formais   expressões regulares podem ser expressas através da   linguagem formal teoria de linguagens formais    elas consistem de constantes e operadores que denotam conjuntos de cadeias de caracteres e operações sobre esses conjuntos  respectivamente  dado um   alfabeto   finito    as seguintes constantes são definidas        conjunto vazio       denotando o conjunto      cadeia de caracteres vazia      denotando o conjunto         literal      a   em   denotando o conjunto    a   as seguintes operações são definidas      concatenação      rs   denotando o conjunto          em   r   e   em   s      por exemplo      ab        c        d        ef           abd        abef        cd        cef          alternância      r s   denotando o conjunto união de   r   e   s    usa-se os símbolos    ou  para alternância ao invés da barra vertical  por exemplo      ab        c        dv        ef           ab        c        dv        ef           fecho de kleene        r    denotando o menor   superconjunto   de   r   que contém   e é   fechamento fechado   sob concatenação  esse é o conjunto de todas as cadeias de caracteres que podem ser construídas ao concatenar zero ou mais cadeias em   r    por exemplo      ab        c               ab        c        abab        abc        cab        cc        ababab        abcab           as constantes e os operadores acima formam a   álgebra de kleene   para evitar parênteses  é assumido que o fecho de kleene possui a maior prioridade  depois a concatenação e por fim a alternância  se não houver ambiguidades  os parênteses podem ser omitidos  por exemplo   code  ab c  code  pode ser escrito como  code abc  code   e  code a  b c     code  pode ser escrito como  code a bc   code   exemplos    code a b   code  denota       a      b      bb      bbb           code  a b    code  denota o conjunto de todas as cadeias de caracteres que contém os símbols   a   e   b    incluindo a cadeia vazia        a      b      aa      ab      ba      bb      aaa           code ab  c     code  denota o conjunto de cadeias de caracteres começando com   a    então com zero ou mais   b  s e opcionalmente com um   c       a      ac      ab      abc      abb        a definição formal de expressões regulares é concisa e evita a utilização dos quantificadores redundantes  code    code  e  code    code   que podem ser expressados respectivamente por  code  a     code  e  code aa   code   por vezes o operador de complemento   é adicionado      r   denota o conjunto das cadeias de caracteres de    que não estão em   r    esse operador é redundante  e pode ser expressado usando outros operadores  apesar da computação para tal representação ser complexa expressões regulares podem expressar   linguagem regular linguagens regulares    a classe de linguagens aceita por um   máquina de estado finito autômato finito    entretanto  há uma diferença significativa na compactação  algumas classes de linguagens regulares podem ser descritas somente por autômatos que crescem exponencialmente em tamanho  enquanto o tamanho das expressões regulares requeridas só pode crescer linearmente  expressões regulares correspondem ao tipo-3 das   gramática formal gramáticas   da   hierarquia de chomsky    por outro lado  existe um mapeamento simples de expressões regulares para máquinas de estado finito não-determinísticas que não leva ao crescimento desgovernado do tamanho  por essa razão  essas máquinas não determinísticas são geralmente usadas como representação alternativa das expressões regulares é possível escrever um   algoritmo   que  para duas expressões regulares dadas  decide se as linguagens descritas são essencialmente iguais  reduz-se cada expressão na máquina de estado finito mínima  e determina-se se ambas as máquinas mínimas são   isomorfismo isomórficas    equivalentes  vale notar que diversas implementações de expressões regulares implementam funcionalidades que não podem ser expressadas na álgebra de kleene  ver    padrões para linguagens não regulares abaixo   mais sobre o assunto    sintaxe       posix    de   1986    a norma   institute of electrical and electronics engineers ieee     posix   1003 2  posix 2  padroniza expressões regulares  e fornece duas especificações  a saber  o conjunto básico  bre  e o conjunto estendido  ere       bre  expressões regulares básicas     a sintaxe tradicional de expressões regulares em unix seguiu convenções comuns  mas diferiu entre as implementações  a norma ieee posix bre    basic regular expressions    do   língua inglesa inglês    expressões regulares básicas  foi desenvolvida primordialmente por compatibilidade com a sintaxe tradicional  mas fornecia uma norma comum que desde então foi adotada por diversas ferramentas na sintaxe de bre  a maioria dos caracteres são tratados como literais   eles casam somente com eles próprios  por exemplo   code a  code  casa    a      as exceções são chamadas metacaracteres ou metassequências  definidos abaixo    class  wikitable  -  metacaractere  descrição -  colspan  2    padrões individuais - valign  top   code    code  casa qualquer caractere  algumas implementações excluem   quebra de linha   e codificação de caracteres  nas expressões posix de listas de caracteres  ver logo abaixo   o caractere ponto é tratado como o literal  por exemplo   code a c  code  casa    abc     etc   mas  code  a c   code  casa somente    a             ou    c     - valign  top   code      code  lista de caracteres  casa uma ocorrência de qualquer caractere contido na lista  por exemplo   code  abc   code  casa    a        b    ou    c     é possível definir intervalos de caracteres   code  a-z   code  casa qualquer caractere de    a    a    z     e  code  0123456789   code  é igual a  code  0-9   code   o caractere  code -  code  é tratado como literal se for o primeiro ou o último da lista  ou se for   seq ência de escape escapado     code  abc-   code    code  -abc   code  ou  code  a -bc   code   - valign  top   code       code  lista negada de caracteres  casa uma ocorrência de qualquer caractere não contido na lista  por exemplo   code   abc   code  casa qualquer caractere que não seja    a        b    ou    c      code   a-z   code  casa qualquer caractere que não esteja em   caixa baixa    -  colspan  2    âncoras - valign  top   code    code  casa o começo da cadeia de caracteres  numa situação de múltiplas linhas  casa o começo das linhas  logo percebe-se que as âncoras não casam pedaços do texto  elas servem apenas como uma referência  - valign  top   code    code  casa o fim da cadeia de caracteres ou a posição logo antes da quebra de linha do fim da cadeia  numa situação de múltiplas linhas  casa o fim das linhas  -  colspan  2    captura de dados - valign  top   br    grupo de captura  marca uma subexpressão  a cadeia de caracteres que casa com o conteúdo dentro dos parênteses pode ser chamada posteriormente  - valign  top   code    n    code  associado com o item anterior  casa a n-ésima subexpressão marcada  em que   n   é um dígito de 1 a 9  essa construção é teoricamente irregular e não foi adotada pela sintaxe posix ere  algumas ferramentas permitem referenciar mais de nove grupos de captura  -  colspan  2    quantificadores  ou repetidores  - valign  top   code    code  casa o elemento precedente zero ou mais vezes  por exemplo   code ab c  code  casa    ac        abc        abbbc     etc    code  xyz    code  casa        x        y        z        zx        zyx        xyzzy     e assim por diante   code   ab     code  casa        ab        abab        ababab     e assim por diante  - valign  top   br    casa o elemento precedente pelo menos   m   vezes e não mais que   n   vezes  por exemplo   code a  3 5    code  casa somente    aaa        aaaa     e    aaaaa     esta funcionalidade não é encontrada em algumas implementações muito antigas  outras opções incluem omitir um dos campos  por exemplo   code a  3     code  casa pelo menos três  a s  já  code a  3    code  casa somente três  a s   code b 0    code  é análogo a  code b   code    code b 0 1   code  é análogo a  code b   code   ver o quantificador  code    code  abaixo  e  code b 1    code  é idêntico a  code b   code   ver o quantificador  code    code  abaixo    uma característica da bre é que os metacaracteres geralmente exigem barras invertidas para serem tratador como tal  por exemplo  em bre   code a 1 2   code  é composto somente por literais  e casará somente    a 1 2      para casar entre uma a duas ocorrências de  a   deve-se usar a expressão regular  code a  1 2    code   a motivação desse sistema é a compatibilidade com sistemas antigos  já que na época da padronização já havia código unix legado que usava chaves como literais      ere  expressões regulares estendidas     o significado dos metacaracteres serem   seq ência de escape escapados   com a barra invertida é revertido na sintaxe posix ere    extended regular expression    do   língua inglesa inglês    expressões regulares estendidas   isso significa que não são usadas   seq ência de escape barras invertidas   para identificar metacaracteres  pelo contrário  elas servem justamente para transformar metacaracteres em literais  retomando o exemplo da seção anterior  em ere   code a 1 2   code  casa uma a duas ocorrências de  a   enquanto  code a  1 2    code  casa o literal    a 1 2     os seguintes metacaracteres foram adicionados    -  colspan  2    quantificadores - valign  top   code    code  casa o elemento precedente zero ou uma vez  por exemplo   code ba   code  casa    b    ou    ba     - valign  top   code    code  casa o elemento precedente uma ou mais vezes  por exemplo   code ba   code  casa    ba        baa        baaa     e assim por diante  como visto na seção de teoria  esse metacaractere pode ser simulado em bre através de  code aa   code   -  colspan  2    alternadores - valign  top   code  nowiki    nowiki   code  casa ou a expressão que precede ou a expressão que sucede  por exemplo   code  nowiki abc def  nowiki   code  casa    abc    ou    def      ferramentas que adotaram a sintaxe incluem   mysql   e   php    esta  que suporta também as derivações de perl no modelo do   perl compatible regular expressions pcre   ref   ref       classes de caracteres     já que diversos grupos de caracteres dependem duma configuração de   locale   específica  a posix define algumas classes  ou categorias  de caracteres para fornecer um método padrão de acesso a alguns grupos específicos de caracteres bastante utilizados  como mostrado na seguinte tabela    -  code   alnum    code  caracteres alfanuméricos  o que no caso de ascii corresponde a  code  a-za-z0-9   code   -  code   alpha    code  caracteres alfabéticos  o que no caso de ascii corresponde a  code  a-za-z   code   -  code   blank    code  espaço e tabulação  o que no caso de ascii corresponde a  code    t   code   -  code   cntrl    code  caracteres de controle  o que no caso de ascii corresponde a  code   x00- x1f x7f   code   -  code   digit    code  dígitos  o que no caso de ascii corresponde a  code  0-9   code   o perl oferece o atalho  code  d  code   -  code   graph    code  caracteres visíveis  o que no caso de ascii corresponde a  code   x21- x7e   code   -  code   lower    code  caracteres em caixa baixa  o que no caso de ascii corresponde a  code  a-z   code   -  code   print    code  caracteres visíveis e espaços  o que no caso de ascii corresponde a  code   x20- x7e   code   -  code   punct    code  caracteres de pontuação  o que no caso de ascii corresponde a  code  nowiki  -                                   nowiki   code   -  code   space    code  caracteres de espaços em branco  o que no caso de ascii corresponde a  code    t r n v f   code   o perl oferece o atalho  code  s  code   que  entretanto  não é exatamente equivalente  diferente do  code  s  code   a classe ainda inclui um tabulador vertical   x11 do ascii  ref name  doc perl    ref  -  code   upper    code  caracteres em caixa alta  o que no caso de ascii corresponde a  code  a-z   code   -  code   xdigit    code  dígitos hexadecimais  o que no caso de ascii corresponde a  code  a-fa-f0-9   code    notar que as doze classes definidas acima também estão definidas na   biblioteca padrão do c    na seção de funções de testes de caracteres do cabeçalho  code ctype h  code  tais classes só podem ser usadas dentro de expressões de listas de caracteres  diferentes   locale  s podem fornecer classes adicionais  uma extensão não posix difundida é  code   word    code   atalho do perl  code  w  code    geralmente definida como  code   alnum    code  ou   traço baixo     code    code   e  code   ascii    code   contendo somente caracteres   ascii     code   x01- x7f   code   pode-se negar uma classe de caracteres precedendo um acento circunflexo ao nome da classe  por exemplo  para negar  code   digit    code  usa-se  code    digit    code   ref name  doc perl         limites de palavras     a norma posix define ainda dois metacaracteres especiais que servem para casar os limites de palavras nas cadeias de caracteres  nesse contexto da posix  uma palavra é formada por caracteres  code   alnum    code  ou   traço baixo     code    code    assim como as âncoras   esses metacaracteres não casam pedaços do texto  elas servem apenas como uma referência  eles são    -  code          code  casa o começo de palavras  -  code          code  casa o fim de palavras       perl e derivações      perl   possui uma sintaxe mais consistente e rica que as normas posix bre e ere  um exemplo é que  code    code  sempre escapa um caractere não alfanumérico  devido ao poder de expressão  outras ferramentas adotaram a sintaxe do perl  como por exemplo   java  linguagem de programação  java   ref   ref     javascript      perl compatible regular expressions pcre      python   ref   ref     ruby  linguagem de programação  ruby   e    net   ref   ref   algumas linguagens e ferramentas como   php   suportam diversos tipos de expressões regulares um exemplo de funcionalidade possível em perl mas não em posix é a quantificação preguiçosa  os quantificadores padrões das expressões regulares são  gananciosos   isto é  casam o quanto puderem    backtracking voltando atrás   somente se necessário para casar o resto da expressão regular  por exemplo  um novato no assunto tentando encontrar a primeira instância de um item entre os símbolos   e   no texto    outra explosão ocorreu em  nowiki  26 de janeiro  de  2004   nowiki     provavelmente usaria o padrão  code       code   ou similar  entretanto  esse padrão retornará     nowiki  26 de janeiro  de  2004   nowiki     ao invés de     nowiki  26 de janeiro   nowiki      como esperado  pois o quantificador  code    code  é ganancioso   ele consumirá a quantidade máxima de caracteres  e     nowiki 26 de janeiro  de  2004  nowiki     possui mais caracteres que    26 de janeiro    apesar desse problema ser evitável de diferentes formas  por exemplo  especificando o que não casar   code  nowiki          nowiki   code    a maioria das ferramentas permitem que um quantificador seja preguiçoso  ou não ganancioso  ao suceder o quantificador com um ponto de interrogação  no exemplo anterior  a alternativa seria  code        code   seguem os quantificadores não gulosos    -  colspan  2    quantificadores não gulosos -  code     code  versão não gulosa de  code    code   dado o texto    aaa      code a   code  casa    a    enquanto  code a    code  casa     -  code     code  versão não gulosa de  code    code   dado o texto    aaa      code a   code  casa    aaa    enquanto  code a    code  casa     -  code     code  versão não gulosa de  code    code   dado o texto    aaa      code a   code  casa    aaa    enquanto  code a    code  casa    a     -  code  m n    code  versão não gulosa de  code  m n   code  dado o texto    aaa      code a 2 3   code  casa    aaa    enquanto  code a 2 3    code  casa    aa      o perl define algumas   seq ência de escape sequências de escape   que servem como atalhos para certos metacaracteres    -  colspan  2    padrões individuais - valign  top   code  s  code  casa espaços em branco   n  r ou  t  - valign  top   code  s  code  negação de  s  casa o que não for espaço em branco   n  r ou  t  - valign  top   code  w  code  casa letras  dígitos  ou      - valign  top   code  w  code  negação de  w - valign  top   code  d  code  casa dígitos  de 0 a 9  - valign  top   code  d  code  negação de  d -  colspan  2    âncoras - valign  top   code  b  code  casa a separação de palavras  o que inclui também o começo   code    code   e o fim   code    code   da cadeia de caracteres testada  a definição dos caracteres que formam palavras varia de acordo com a implementação  mas é seguro assumir pelo menos  code  a-za-z0-9    code   havendo suporte  o atalho  code  w  code  é uma alternativa válida  o   java  linguagem de programação  java   é uma notável exceção na medida em que suporta  code  b  code  mas não  code  w  code   notar que apesar de parecida com os limites de palavras definidos pela posix  esta sequência de escape não distingue o começo e o final da palavra  somente a separação em si  - valign  top   code  b  code  negação de  b - valign  top   code  a  code  casa o começo da cadeia de caracteres  numa situação de múltiplas linhas  não casa o começo das linhas seguintes  o que a difere de  code    code    - valign  top   code  z  code  casa o fim da cadeia de caracteres ou a posição logo antes da quebra de linha do fim da cadeia  numa situação de múltiplas linhas  não casa o fim das linhas seguintes  o que a difere de  code    code   - valign  top   code  z  code  casa o fim da cadeia de caracteres   além dos quantificadores preguiçosos e das novas sequências de escape  o perl também adicionou uma forma nova de casamento de padrões que estendem a posix  são um conjunto de metacaracteres que seguem o padrão  code       code   listados abaixo    - valign  top   code        code  adiciona um comentário  ignorado nos casamentos  - valign  top   code        code  grupo de captura que não é salvo para rechamada posterior   code  1  code    code  2  code    code  3  code        - valign  top   code        code  casa ocorrências do padrão atual a partir da posição atual até o final  assim como as âncoras   code    code    code    code    o padrão não é incluído no casamento  servindo apenas na verificação  por exemplo  o padrão  code carro   azul   code  aplicado a    um carro esportivo azul barato     casará    carro     - valign  top   code        code  negação de  code       code   casa a ausência do padrão atual a partir da posição atual até o final  e também não inclui o padrão no casamento  por exemplo  o padrão  code carro   amarelo   code  casará em    um carro esportivo azul barato      entretanto  code carro   azul   code  não casará  - valign  top   code         code  casa ocorrências do padrão atual a partir do começo até a posição atual  mas não inclui o padrão no casamento  servindo apenas na verificação  por exemplo  o padrão  code     carro azul  code  aplicado a    um carro esportivo azul barato     casará    azul     - valign  top   code         code  negação de  code        code   casa a ausência do padrão atual a partir do começo até a posição atual  e também não inclui o padrão no casamento  por exemplo  o padrão  code     carro amarelo  code  casará em    um carro esportivo azul barato      entretanto  code     carro azul  code  não casará  - valign  top   code       code  aplica modificadores a partes da expressão regular  os valores aceitos são i  ignora diferenças entre maiúsculas e minúsculas   m  texto multilinha   s  texto monolinha  e x  inclusão de espaços e comentários   - valign  top   code    a b c   code  um   operação ternária programação operador ternário    usado geralmente em conjunto dos grupos de captura  por exemplo  a escolha duma ou outra subexpressão regular depende dum casamento ou não anterior  - valign  top   code    a b   code  variação binária da estrutura anterior  em que uma expressão é adicionada ao padrão   se e somente se   a condição é verdadeira      padrões para linguagens não regulares   diversas funcionalidades encontradas em bibliotecas atuais de expressões regulares provem um poder de expressão que excede as   linguagem regular linguagens regulares    por exemplo  a habilidade de agrupar subexpressões com parênteses e chamar novamente o valor casado na mesma expressão significa que o padrão pode casar cadeias de palavras repetidas como    papa    ou    wikiwiki     os chamados quadrados na teoria de linguagens formais  o padrão para essas cadeias é  code      1  code   entretanto  a linguagem de quadrados não é regular  nem   linguagem livre de contexto livre de contexto      casamento de padrões   com um número indeterminado de referências anteriores  como suportado em ferramentas atuais  é   np-difícil   entretanto  as ferramentas que fornecem tais construções ainda usam o termo expressões regulares para os padrões  o que leva a uma nomenclatura que difere da teoria das linguagens formais  por essa razão  algumas pessoas usam o termo   regex   ou simplesmente   padrão   para descrever esse conceito mais abrangente    implementações   existem pelo menos dois   algoritmo  s fundamentalmente diferentes entre si que decidem se e como uma expressão regular casa uma cadeia de caracteres o mais antigo e mais rápido faz uso dum princípio da teoria de linguagens formais que permite a todas as máquinas de estado finito não determinísticas serem transformadas em máquinas de estado finito determinísticas  geralmente chamado de dfa  o algoritmo realiza ou simula tal transformação e então executa a máquina determinística resultante na cadeia de caracteres  um símbolo de cada vez  esse último processo tem   complexidade linear   relativa ao tamanho da cadeia de caracteres  mais precisamente  uma cadeia de caracteres de tamanho   n   pode ser testada numa expressão regular de tamanho   m   no tempo   grande-o   o        math n 2 m  math     ou   o      math nm  math      dependendo dos detalhes de implementação  esse algoritmo é rápido  mas pode ser usado somente para casamentos e não para a rechamada de grupos de captura  quantificação preguiçosa e diversas outras funcionalidades encontradas nas bibliotecas modernas de expressões regulares  também é possível executar a máquina não determinística diretamente  construindo cada estado da máquina determinística quando necessário e então descartando-o no próximo passo  isso evita a quantidade exponencial de memória necessária para a construção completa da máquina determinística  ainda que garantindo a busca em tempo linear  ref   ref o outro algoritmo é casar o padrão com a cadeia de caracteres através de     backtracking      geralmente chamado de nfa  seu tempo de execução pode ser   complexidade exponencial exponencial    o que pode acontecer em implementações simples no casamento de expressões como  code  a aa  b  code   que forçam o algoritmo a considerar um número exponencial de subcasos  implementações modernas geralmente identificam tais casos  e aceleram e abortam a execução  apesar dessas implementações com   backtracking   garantirem tempo exponencial no pior caso  elas fornecem mais flexibilidade e poder de expressão    relacionamento com unicode   originalmente  as expressões regulares eram usadas com caracteres   american standard code for information interchange ascii    mas várias implementações atuais suportam   unicode    na maioria dos casos não há diferença entre conjuntos de caracteres  mas algumas questões são relevantes ao suportar unicode uma delas é a codificação suportada  já que algumas implementações esperam   utf-8    enquanto outras podem esperar   utf-16   ou   utf-32    outra questão é estender as funcionalidades disponíveis para ascii no unicode  por exemplo  em implementações ascii  conjuntos de caracteres na forma  code  x-y   code  são válidos para quaisquer   x   e   y   no intervalo  0x00 0x7f  desde que o código de   x   seja menor que o código de   y    a escolha natural seria permitir o mesmo em unicode no intervalo de códigos  0 0x10ffff   o que não é possível pois algumas implementações não permitem que conjuntos de caracteres ultrapassem os blocos de código disponíveis do ponto de vista dos detalhes técnicos do unicode  também surgem questões  como a normalização  pois  em unicode  mais de um código pode representar o mesmo caractere  por exemplo  o caractere    é    pode ser representado por u 0065  letra latina    e    minúsculo  combinado com u 0301  diacrítico    acento agudo      mas também pode ser representado como u 00e9  letra latina  e  com diacrítico  acento agudo    também há os códigos de controle unicode  as marcas de ordem de byte e as marcas de direção de texto  que devem ser tratados separadamente    uso   expressões regulares são usadas por diversos   editor de texto editores de texto      utilitário  s e   linguagem de programação linguagens de programação   para procurar e manipular texto baseado em padrões  por exemplo    perl   e   tcl   possuem suporte a expressões regulares nativamente  diversos utilitários de distribuições   unix   incluem o editor de texto   ed  software  ed    que popularizou o conceito de expressão regular  e o filtro   grep   outro uso é a validação de formatos de texto  validação de protocolos ou formatos digitais   por exemplo  ao receber a entrada dum campo de formulário duma aplicação que supõe receber um endereço de     email      pode-se usar uma expressão regular para garantir que o que foi recebido de fato é um endereço de   email   mais um uso é a implementação interna dum sistema de   realce de sintaxe    como encontrado em   ambiente de desenvolvimento integrado ambientes de desenvolvimento integrado    expressões regulares podem ser usadas para encontrar   palavra reservada palavras reservadas    literais e outros tokens específicos  e para alterar a formatação do texto de acordo com o casamento feito um uso difundido de expressões regulares é a filtragem de informação em bancos de dados de texto  por exemplo  num arquivo de texto contendo cadastros de pessoas e suas datas de aniversário como a seguir  1954-10-01 joão alberto 1976-07-25 maria eduarda 1966-10-22 carlos silvapode-se filtrar pessoas que nasceram num determinado ano  mês ou dia  por exemplo  o uso do padrão  code   0-9  4 -10- 0-9  2         code  identifica o nome das pessoas que nasceram em outubro  para o cadastro acima seriam retornados dois grupos de captura   code  1  code  contendo    joão alberto    e  code  2  code  contendo    carlos silva     explorando o exemplo anterior e o uso de validação de formatos digitais  é possível usar expressões regulares para validar as datas presentes no arquivo de texto de aniversários acima  o padrão  code  19 20  d d  -      0 1-9  1 012   2  012  0-9  3 01    code  é usado para validar uma data entre 1900-01-01 e 2099-12-31  ref   ref  atentar que a separação entre ano  mês e dia pode se dar através de hífen  espaço em branco  barra ou ponto  mas deve-se usar o mesmo símbolo de separação entre ano e mês e entre mês e dia  o que é possível através da rechamada do grupo de captura anterior  o trecho  code  2  code  do padrão   atentar também que o padrão é incompleto na medida em que não diferencia a quantidade de dias em cada mês  o que resulta no casamento duma cadeia de caracteres    2000-02-31     incorreta de acordo com o   calendário gregoriano                                    ver também       editor de texto      teoria da computação      autômato      linguagem regular      casamento de padrões     ligações externas      http   guia-er sourceforge net manual de regex    http   aurelio net er portal sobre expressões regulares    http   www regex pro br wiki sobre expressões regulares   categoria linguagens formais  